<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Recast/Detour: dtNavMeshQuery Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Recast/Detour
   &#160;<span id="projectnumber">2.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdtNavMeshQuery.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classdtNavMeshQuery-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">dtNavMeshQuery Class Reference<div class="ingroups"><a class="el" href="group__detour.html">Detour</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides the ability to perform pathfinding related queries against a navigation mesh.  
 <a href="classdtNavMeshQuery.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DetourNavMeshQuery_8h_source.html">DetourNavMeshQuery.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa5adfa9c92f7d77bb144c3283bf76d2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#aa5adfa9c92f7d77bb144c3283bf76d2e">dtNavMeshQuery</a> ()</td></tr>
<tr class="separator:aa5adfa9c92f7d77bb144c3283bf76d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157a41114dab708dabb05eebe8dc07a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a157a41114dab708dabb05eebe8dc07a2">~dtNavMeshQuery</a> ()</td></tr>
<tr class="separator:a157a41114dab708dabb05eebe8dc07a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb51d0d2798d0bc7c669ac38c25d4116"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#acb51d0d2798d0bc7c669ac38c25d4116">init</a> (const <a class="el" href="classdtNavMesh.html">dtNavMesh</a> *nav, const int maxNodes)</td></tr>
<tr class="memdesc:acb51d0d2798d0bc7c669ac38c25d4116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the query object.  <a href="#acb51d0d2798d0bc7c669ac38c25d4116">More...</a><br/></td></tr>
<tr class="separator:acb51d0d2798d0bc7c669ac38c25d4116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Standard Pathfinding Functions</div></td></tr>
<tr class="memitem:a9b9365505bb65ffb5d622d0ae48ba100"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a9b9365505bb65ffb5d622d0ae48ba100">findPath</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> endRef, const float *startPos, const float *endPos, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *path, int *pathCount, const int maxPath, float *pathCost=0) const </td></tr>
<tr class="memdesc:a9b9365505bb65ffb5d622d0ae48ba100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a path from the start polygon to the end polygon.  <a href="#a9b9365505bb65ffb5d622d0ae48ba100">More...</a><br/></td></tr>
<tr class="separator:a9b9365505bb65ffb5d622d0ae48ba100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42040cc55792543570e6078e524e7a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#ac42040cc55792543570e6078e524e7a9">findStraightPath</a> (const float *startPos, const float *endPos, const <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *path, const int pathSize, float *straightPath, unsigned char *straightPathFlags, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *straightPathRefs, int *straightPathCount, const int maxStraightPath, const int options=0) const </td></tr>
<tr class="memdesc:ac42040cc55792543570e6078e524e7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the straight path from the start to the end position within the polygon corridor.  <a href="#ac42040cc55792543570e6078e524e7a9">More...</a><br/></td></tr>
<tr class="separator:ac42040cc55792543570e6078e524e7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Sliced Pathfinding Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Common use case:</p>
<ol type="1">
<li>Call <a class="el" href="classdtNavMeshQuery.html#a16e37c345635df5b3a38b4ea0b9bdbb1" title="Intializes a sliced path query. ">initSlicedFindPath()</a> to initialize the sliced path query.</li>
<li>Call <a class="el" href="classdtNavMeshQuery.html#aa0c147e3da7fd0b59342da0fc456afc7" title="Updates an in-progress sliced path query. ">updateSlicedFindPath()</a> until it returns complete.</li>
<li>Call <a class="el" href="classdtNavMeshQuery.html#a98673bb238fbb139ec8407e266fa76fd" title="Finalizes and returns the results of a sliced path query. ">finalizeSlicedFindPath()</a> to get the path. </li>
</ol>
</div></td></tr>
<tr class="memitem:a16e37c345635df5b3a38b4ea0b9bdbb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a16e37c345635df5b3a38b4ea0b9bdbb1">initSlicedFindPath</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> endRef, const float *startPos, const float *endPos, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter)</td></tr>
<tr class="memdesc:a16e37c345635df5b3a38b4ea0b9bdbb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intializes a sliced path query.  <a href="#a16e37c345635df5b3a38b4ea0b9bdbb1">More...</a><br/></td></tr>
<tr class="separator:a16e37c345635df5b3a38b4ea0b9bdbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c147e3da7fd0b59342da0fc456afc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#aa0c147e3da7fd0b59342da0fc456afc7">updateSlicedFindPath</a> (const int maxIter, int *doneIters)</td></tr>
<tr class="memdesc:aa0c147e3da7fd0b59342da0fc456afc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates an in-progress sliced path query.  <a href="#aa0c147e3da7fd0b59342da0fc456afc7">More...</a><br/></td></tr>
<tr class="separator:aa0c147e3da7fd0b59342da0fc456afc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98673bb238fbb139ec8407e266fa76fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a98673bb238fbb139ec8407e266fa76fd">finalizeSlicedFindPath</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *path, int *pathCount, const int maxPath)</td></tr>
<tr class="memdesc:a98673bb238fbb139ec8407e266fa76fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes and returns the results of a sliced path query.  <a href="#a98673bb238fbb139ec8407e266fa76fd">More...</a><br/></td></tr>
<tr class="separator:a98673bb238fbb139ec8407e266fa76fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b18dcb5d25fc392b6030ae5d4f310e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a01b18dcb5d25fc392b6030ae5d4f310e">finalizeSlicedFindPathPartial</a> (const <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *existing, const int existingSize, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *path, int *pathCount, const int maxPath)</td></tr>
<tr class="memdesc:a01b18dcb5d25fc392b6030ae5d4f310e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes and returns the results of an incomplete sliced path query, returning the path to the furthest polygon on the existing path that was visited during the search.  <a href="#a01b18dcb5d25fc392b6030ae5d4f310e">More...</a><br/></td></tr>
<tr class="separator:a01b18dcb5d25fc392b6030ae5d4f310e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dijkstra Search Functions</div></td></tr>
<tr class="memitem:a4698116e919e95ce661e695c2ce214d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a4698116e919e95ce661e695c2ce214d2">findPolysAroundCircle</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *centerPos, const float radius, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *resultRef, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *resultParent, float *resultCost, int *resultCount, const int maxResult) const </td></tr>
<tr class="memdesc:a4698116e919e95ce661e695c2ce214d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the polygons along the navigation graph that touch the specified circle.  <a href="#a4698116e919e95ce661e695c2ce214d2">More...</a><br/></td></tr>
<tr class="separator:a4698116e919e95ce661e695c2ce214d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c117e7a7c9de9cc1b78c3b157f6beed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a4c117e7a7c9de9cc1b78c3b157f6beed">findPolysAroundShape</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *verts, const int nverts, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *resultRef, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *resultParent, float *resultCost, int *resultCount, const int maxResult) const </td></tr>
<tr class="memdesc:a4c117e7a7c9de9cc1b78c3b157f6beed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the polygons along the naviation graph that touch the specified convex polygon.  <a href="#a4c117e7a7c9de9cc1b78c3b157f6beed">More...</a><br/></td></tr>
<tr class="separator:a4c117e7a7c9de9cc1b78c3b157f6beed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Local Query Functions</div></td></tr>
<tr class="memitem:a4cb8e009cbddba93a37372ad06e88ab1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a4cb8e009cbddba93a37372ad06e88ab1">findNearestPoly</a> (const float *center, const float *extents, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *nearestRef, float *nearestPt) const </td></tr>
<tr class="memdesc:a4cb8e009cbddba93a37372ad06e88ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the polygon nearest to the specified center point.  <a href="#a4cb8e009cbddba93a37372ad06e88ab1">More...</a><br/></td></tr>
<tr class="separator:a4cb8e009cbddba93a37372ad06e88ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3e80791c1d29b6defa5fb17682ec1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#aee3e80791c1d29b6defa5fb17682ec1d">queryPolygons</a> (const float *center, const float *extents, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *polys, int *polyCount, const int maxPolys) const </td></tr>
<tr class="memdesc:aee3e80791c1d29b6defa5fb17682ec1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds polygons that overlap the search box.  <a href="#aee3e80791c1d29b6defa5fb17682ec1d">More...</a><br/></td></tr>
<tr class="separator:aee3e80791c1d29b6defa5fb17682ec1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23755989dd4e84c8c1e9d9188e8a970f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a23755989dd4e84c8c1e9d9188e8a970f">findLocalNeighbourhood</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *centerPos, const float radius, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *resultRef, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *resultParent, int *resultCount, const int maxResult) const </td></tr>
<tr class="memdesc:a23755989dd4e84c8c1e9d9188e8a970f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the non-overlapping navigation polygons in the local neighbourhood around the center position.  <a href="#a23755989dd4e84c8c1e9d9188e8a970f">More...</a><br/></td></tr>
<tr class="separator:a23755989dd4e84c8c1e9d9188e8a970f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4652499f16b04137b920123f224909b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a4652499f16b04137b920123f224909b7">moveAlongSurface</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *startPos, const float *endPos, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, float *resultPos, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *visited, int *visitedCount, const int maxVisitedSize) const </td></tr>
<tr class="memdesc:a4652499f16b04137b920123f224909b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves from the start to the end position constrained to the navigation mesh.  <a href="#a4652499f16b04137b920123f224909b7">More...</a><br/></td></tr>
<tr class="separator:a4652499f16b04137b920123f224909b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7ef4c9350246c5b3b935385a90a79e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a8c7ef4c9350246c5b3b935385a90a79e">raycast</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *startPos, const float *endPos, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, float *t, float *hitNormal, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *path, int *pathCount, const int maxPath) const </td></tr>
<tr class="memdesc:a8c7ef4c9350246c5b3b935385a90a79e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a 'walkability' ray along the surface of the navigation mesh from the start position toward the end position.  <a href="#a8c7ef4c9350246c5b3b935385a90a79e">More...</a><br/></td></tr>
<tr class="separator:a8c7ef4c9350246c5b3b935385a90a79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7418695cbd5d00e2785a187fff336e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#ae7418695cbd5d00e2785a187fff336e4">findDistanceToWall</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *centerPos, const float maxRadius, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, float *hitDist, float *hitPos, float *hitNormal) const </td></tr>
<tr class="memdesc:ae7418695cbd5d00e2785a187fff336e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the distance from the specified position to the nearest polygon wall.  <a href="#ae7418695cbd5d00e2785a187fff336e4">More...</a><br/></td></tr>
<tr class="separator:ae7418695cbd5d00e2785a187fff336e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ff91171b3455e8c99a5faef19a548f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a98ff91171b3455e8c99a5faef19a548f">getPolyWallSegments</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> ref, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, float *segmentVerts, <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *segmentRefs, int *segmentCount, const int maxSegments) const </td></tr>
<tr class="memdesc:a98ff91171b3455e8c99a5faef19a548f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the segments for the specified polygon, optionally including portals.  <a href="#a98ff91171b3455e8c99a5faef19a548f">More...</a><br/></td></tr>
<tr class="separator:a98ff91171b3455e8c99a5faef19a548f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed13fcbe5441ba9d200b7153d0ed458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a1ed13fcbe5441ba9d200b7153d0ed458">findRandomPoint</a> (const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, float(*frand)(), <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *randomRef, float *randomPt) const </td></tr>
<tr class="memdesc:a1ed13fcbe5441ba9d200b7153d0ed458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns random location on navmesh.  <a href="#a1ed13fcbe5441ba9d200b7153d0ed458">More...</a><br/></td></tr>
<tr class="separator:a1ed13fcbe5441ba9d200b7153d0ed458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc139c4fd304f68aa72684dc10b000a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a2fc139c4fd304f68aa72684dc10b000a">findRandomPointAroundCircle</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> startRef, const float *centerPos, const float maxRadius, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter, float(*frand)(), <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *randomRef, float *randomPt) const </td></tr>
<tr class="memdesc:a2fc139c4fd304f68aa72684dc10b000a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns random location on navmesh within the reach of specified location.  <a href="#a2fc139c4fd304f68aa72684dc10b000a">More...</a><br/></td></tr>
<tr class="separator:a2fc139c4fd304f68aa72684dc10b000a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace375a2d8b236abcd3fc05c38def4810"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#ace375a2d8b236abcd3fc05c38def4810">closestPointOnPoly</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> ref, const float *pos, float *closest) const </td></tr>
<tr class="memdesc:ace375a2d8b236abcd3fc05c38def4810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the closest point on the specified polygon.  <a href="#ace375a2d8b236abcd3fc05c38def4810">More...</a><br/></td></tr>
<tr class="separator:ace375a2d8b236abcd3fc05c38def4810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f3f4e7be8121e8abfc9dbed3e54d00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a66f3f4e7be8121e8abfc9dbed3e54d00">closestPointOnPolyBoundary</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> ref, const float *pos, float *closest) const </td></tr>
<tr class="memdesc:a66f3f4e7be8121e8abfc9dbed3e54d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a point on the boundary closest to the source point if the source point is outside the polygon's xz-bounds.  <a href="#a66f3f4e7be8121e8abfc9dbed3e54d00">More...</a><br/></td></tr>
<tr class="separator:a66f3f4e7be8121e8abfc9dbed3e54d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba30d075826336a6ad68624e4cc3c47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a3ba30d075826336a6ad68624e4cc3c47">getPolyHeight</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> ref, const float *pos, float *height) const </td></tr>
<tr class="memdesc:a3ba30d075826336a6ad68624e4cc3c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the height of the polygon at the provided position using the height detail.  <a href="#a3ba30d075826336a6ad68624e4cc3c47">More...</a><br/></td></tr>
<tr class="separator:a3ba30d075826336a6ad68624e4cc3c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous Functions</div></td></tr>
<tr class="memitem:af297613a9433a98f85cdadcba298bc16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#af297613a9433a98f85cdadcba298bc16">isValidPolyRef</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> ref, const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *filter) const </td></tr>
<tr class="memdesc:af297613a9433a98f85cdadcba298bc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the polygon reference is valid and passes the filter restrictions.  <a href="#af297613a9433a98f85cdadcba298bc16">More...</a><br/></td></tr>
<tr class="separator:af297613a9433a98f85cdadcba298bc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c545e9d04c75c7e5f895cb8f4b5ab86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a8c545e9d04c75c7e5f895cb8f4b5ab86">isInClosedList</a> (<a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> ref) const </td></tr>
<tr class="memdesc:a8c545e9d04c75c7e5f895cb8f4b5ab86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the polygon reference is in the closed list.  <a href="#a8c545e9d04c75c7e5f895cb8f4b5ab86">More...</a><br/></td></tr>
<tr class="separator:a8c545e9d04c75c7e5f895cb8f4b5ab86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad342acec1028a02af2a45910f15e7bdb"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="classdtNodePool.html">dtNodePool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#ad342acec1028a02af2a45910f15e7bdb">getNodePool</a> () const </td></tr>
<tr class="memdesc:ad342acec1028a02af2a45910f15e7bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the node pool.  <a href="#ad342acec1028a02af2a45910f15e7bdb">More...</a><br/></td></tr>
<tr class="separator:ad342acec1028a02af2a45910f15e7bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf7b20019f41314efa52f6fc9f4789a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdtNavMesh.html">dtNavMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdtNavMeshQuery.html#a6bf7b20019f41314efa52f6fc9f4789a">getAttachedNavMesh</a> () const </td></tr>
<tr class="memdesc:a6bf7b20019f41314efa52f6fc9f4789a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the navigation mesh the query object is using.  <a href="#a6bf7b20019f41314efa52f6fc9f4789a">More...</a><br/></td></tr>
<tr class="separator:a6bf7b20019f41314efa52f6fc9f4789a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides the ability to perform pathfinding related queries against a navigation mesh. </p>
<p>For methods that support undersized buffers, if the buffer is too small to hold the entire result set the return status of the method will include the <a class="el" href="DetourStatus_8h.html#a97c8292e3ce2ba0b63bfa4ca57de10af">DT_BUFFER_TOO_SMALL</a> flag.</p>
<p>Constant member functions can be used by multiple clients without side effects. (E.g. No change to the closed list. No impact on an in-progress sliced path query. Etc.)</p>
<p>Walls and portals: A <em>wall</em> is a polygon segment that is considered impassable. A <em>portal</em> is a passable segment between polygons. A portal may be treated as a wall based on the <a class="el" href="classdtQueryFilter.html" title="Defines polygon filtering and traversal costs for navigation mesh query operations. ">dtQueryFilter</a> used for a query.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classdtNavMesh.html" title="A navigation mesh based on tiles of convex polygons. ">dtNavMesh</a>, <a class="el" href="classdtQueryFilter.html" title="Defines polygon filtering and traversal costs for navigation mesh query operations. ">dtQueryFilter</a>, <a class="el" href="group__detour.html#gae547f165feefc955136130c8e22f207a" title="Allocates a query object using the Detour allocator. ">dtAllocNavMeshQuery()</a>, <a class="el" href="group__detour.html#gae547f165feefc955136130c8e22f207a" title="Allocates a query object using the Detour allocator. ">dtAllocNavMeshQuery()</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa5adfa9c92f7d77bb144c3283bf76d2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtNavMeshQuery::dtNavMeshQuery </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a157a41114dab708dabb05eebe8dc07a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dtNavMeshQuery::~dtNavMeshQuery </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ace375a2d8b236abcd3fc05c38def4810"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::closestPointOnPoly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>closest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the closest point on the specified polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The reference id of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The position to check. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest</td><td>The closest point on the polygon. [(x, y, z)] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Uses the detail polygons to find the surface height. (Most accurate.)</p>
<p><code>pos</code> does not have to be within the bounds of the polygon or navigation mesh.</p>
<p>See <a class="el" href="classdtNavMeshQuery.html#a66f3f4e7be8121e8abfc9dbed3e54d00" title="Returns a point on the boundary closest to the source point if the source point is outside the polygo...">closestPointOnPolyBoundary()</a> for a limited but faster option. </p>

</div>
</div>
<a class="anchor" id="a66f3f4e7be8121e8abfc9dbed3e54d00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::closestPointOnPolyBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>closest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a point on the boundary closest to the source point if the source point is outside the polygon's xz-bounds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The reference id to the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The position to check. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest</td><td>The closest point. [(x, y, z)] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Much faster than <a class="el" href="classdtNavMeshQuery.html#ace375a2d8b236abcd3fc05c38def4810" title="Finds the closest point on the specified polygon. ">closestPointOnPoly()</a>.</p>
<p>If the provided position lies within the polygon's xz-bounds (above or below), then <code>pos</code> and <code>closest</code> will be equal.</p>
<p>The height of <code>closest</code> will be the polygon boundary. The height detail is not used.</p>
<p><code>pos</code> does not have to be within the bounds of the polybon or the navigation mesh. </p>

</div>
</div>
<a class="anchor" id="a98673bb238fbb139ec8407e266fa76fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::finalizeSlicedFindPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pathCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes and returns the results of a sliced path query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">path</td><td>An ordered list of polygon references representing the path. (Start to end.) [(polyRef) * <code>pathCount</code>] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pathCount</td><td>The number of polygons returned in the <code>path</code> array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPath</td><td>The max number of polygons the path array can hold. [Limit: &gt;= 1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a class="anchor" id="a01b18dcb5d25fc392b6030ae5d4f310e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::finalizeSlicedFindPathPartial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>existing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>existingSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pathCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes and returns the results of an incomplete sliced path query, returning the path to the furthest polygon on the existing path that was visited during the search. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">existing</td><td>An array of polygon references for the existing path. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">existingSize</td><td>The number of polygon in the <code>existing</code> array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">path</td><td>An ordered list of polygon references representing the path. (Start to end.) [(polyRef) * <code>pathCount</code>] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pathCount</td><td>The number of polygons returned in the <code>path</code> array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPath</td><td>The max number of polygons the <code>path</code> array can hold. [Limit: &gt;= 1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7418695cbd5d00e2785a187fff336e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::findDistanceToWall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>centerPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>maxRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hitDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hitPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hitNormal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the distance from the specified position to the nearest polygon wall. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the polygon containing <code>centerPos</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centerPos</td><td>The center of the search circle. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxRadius</td><td>The radius of the search circle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hitDist</td><td>The distance to the nearest wall from <code>centerPos</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hitPos</td><td>The nearest position on the wall that was hit. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hitNormal</td><td>The normalized ray formed from the wall point to the source point. [(x, y, z)] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p><code>hitPos</code> is not adjusted using the height detail data.</p>
<p><code>hitDist</code> will equal the search radius if there is no wall within the radius. In this case the values of <code>hitPos</code> and <code>hitNormal</code> are undefined.</p>
<p>The normal will become unpredicable if <code>hitDist</code> is a very small number. </p>

</div>
</div>
<a class="anchor" id="a23755989dd4e84c8c1e9d9188e8a970f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::findLocalNeighbourhood </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>centerPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>resultRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>resultParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>resultCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the non-overlapping navigation polygons in the local neighbourhood around the center position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the polygon where the search starts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centerPos</td><td>The center of the query circle. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>The radius of the query circle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultRef</td><td>The reference ids of the polygons touched by the circle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultParent</td><td>The reference ids of the parent polygons for each result. Zero if a result polygon has no parent. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultCount</td><td>The number of polygons found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxResult</td><td>The maximum number of polygons the result arrays can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>This method is optimized for a small search radius and small number of result polygons.</p>
<p>Candidate polygons are found by searching the navigation graph beginning at the start polygon.</p>
<p>The same intersection test restrictions that apply to the findPolysAroundCircle mehtod applies to this method.</p>
<p>The value of the center point is used as the start point for cost calculations. It is not projected onto the surface of the mesh, so its y-value will effect the costs.</p>
<p>Intersection tests occur in 2D. All polygons and the search circle are projected onto the xz-plane. So the y-value of the center point does not effect intersection tests.</p>
<p>If the result arrays are is too small to hold the entire result set, they will be filled to capacity. </p>

</div>
</div>
<a class="anchor" id="a4cb8e009cbddba93a37372ad06e88ab1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::findNearestPoly </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>nearestRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>nearestPt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the polygon nearest to the specified center point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">center</td><td>The center of the search box. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extents</td><td>The search distance along each axis. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nearestRef</td><td>The reference id of the nearest polygon. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nearestPt</td><td>The nearest point on the polygon. [opt] [(x, y, z)] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the search box does not intersect any polygons the search will return <a class="el" href="DetourStatus_8h.html#ace78a9666e74d996b468942e7434989a">DT_SUCCESS</a>, but <code>nearestRef</code> will be zero. So if in doubt, check <code>nearestRef</code> before using <code>nearestPt</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not suitable for large area searches. If the search extents overlaps more than 128 polygons it may return an invalid result. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b9365505bb65ffb5d622d0ae48ba100"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::findPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>endRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pathCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pathCost</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a path from the start polygon to the end polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The refrence id of the start polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endRef</td><td>The reference id of the end polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startPos</td><td>A position within the start polygon. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endPos</td><td>A position within the end polygon. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">path</td><td>An ordered list of polygon references representing the path. (Start to end.) [(polyRef) * <code>pathCount</code>] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pathCount</td><td>The number of polygons returned in the <code>path</code> array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPath</td><td>The maximum number of polygons the <code>path</code> array can hold. [Limit: &gt;= 1] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pathCost</td><td>The cost of the path found (0 if no path is found).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>If the end polygon cannot be reached through the navigation graph, the last polygon in the path will be the nearest the end polygon.</p>
<p>If the path array is to small to hold the full result, it will be filled as far as possible from the start polygon toward the end polygon.</p>
<p>The start and end positions are used to calculate traversal costs. (The y-values impact the result.) </p>

</div>
</div>
<a class="anchor" id="a4698116e919e95ce661e695c2ce214d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::findPolysAroundCircle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>centerPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>resultRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>resultParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>resultCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>resultCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the polygons along the navigation graph that touch the specified circle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the polygon where the search starts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centerPos</td><td>The center of the search circle. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>The radius of the search circle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultRef</td><td>The reference ids of the polygons touched by the circle. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultParent</td><td>The reference ids of the parent polygons for each result. Zero if a result polygon has no parent. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultCost</td><td>The search cost from <code>centerPos</code> to the polygon. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultCount</td><td>The number of polygons found. [opt] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxResult</td><td>The maximum number of polygons the result arrays can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>At least one result array must be provided.</p>
<p>The order of the result set is from least to highest cost to reach the polygon.</p>
<p>A common use case for this method is to perform Dijkstra searches. Candidate polygons are found by searching the graph beginning at the start polygon.</p>
<p>If a polygon is not found via the graph search, even if it intersects the search circle, it will not be included in the result set. For example:</p>
<p>polyA is the start polygon. polyB shares an edge with polyA. (Is adjacent.) polyC shares an edge with polyB, but not with polyA Even if the search circle overlaps polyC, it will not be included in the result set unless polyB is also in the set.</p>
<p>The value of the center point is used as the start position for cost calculations. It is not projected onto the surface of the mesh, so its y-value will effect the costs.</p>
<p>Intersection tests occur in 2D. All polygons and the search circle are projected onto the xz-plane. So the y-value of the center point does not effect intersection tests.</p>
<p>If the result arrays are to small to hold the entire result set, they will be filled to capacity. </p>

</div>
</div>
<a class="anchor" id="a4c117e7a7c9de9cc1b78c3b157f6beed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::findPolysAroundShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nverts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>resultRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>resultParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>resultCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>resultCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the polygons along the naviation graph that touch the specified convex polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the polygon where the search starts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verts</td><td>The vertices describing the convex polygon. (CCW) [(x, y, z) * <code>nverts</code>] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nverts</td><td>The number of vertices in the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultRef</td><td>The reference ids of the polygons touched by the search polygon. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultParent</td><td>The reference ids of the parent polygons for each result. Zero if a result polygon has no parent. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultCost</td><td>The search cost from the centroid point to the polygon. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultCount</td><td>The number of polygons found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxResult</td><td>The maximum number of polygons the result arrays can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>The order of the result set is from least to highest cost.</p>
<p>At least one result array must be provided.</p>
<p>A common use case for this method is to perform Dijkstra searches. Candidate polygons are found by searching the graph beginning at the start polygon.</p>
<p>The same intersection test restrictions that apply to <a class="el" href="classdtNavMeshQuery.html#a4698116e919e95ce661e695c2ce214d2" title="Finds the polygons along the navigation graph that touch the specified circle. ">findPolysAroundCircle()</a> method apply to this method.</p>
<p>The 3D centroid of the search polygon is used as the start position for cost calculations.</p>
<p>Intersection tests occur in 2D. All polygons are projected onto the xz-plane. So the y-values of the vertices do not effect intersection tests.</p>
<p>If the result arrays are is too small to hold the entire result set, they will be filled to capacity. </p>

</div>
</div>
<a class="anchor" id="a1ed13fcbe5441ba9d200b7153d0ed458"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::findRandomPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float(*)()&#160;</td>
          <td class="paramname"><em>frand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>randomRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>randomPt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns random location on navmesh. </p>
<p>Polygons are chosen weighted by area. The search runs in linear related to number of polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frand</td><td>Function returning a random number [0..1). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">randomRef</td><td>The reference id of the random location. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">randomPt</td><td>The random location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fc139c4fd304f68aa72684dc10b000a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::findRandomPointAroundCircle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>centerPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>maxRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float(*)()&#160;</td>
          <td class="paramname"><em>frand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>randomRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>randomPt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns random location on navmesh within the reach of specified location. </p>
<p>Polygons are chosen weighted by area. The search runs in linear related to number of polygon. The location is not exactly constrained by the circle, but it limits the visited polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the polygon where the search starts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centerPos</td><td>The center of the search circle. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxRadius</td><td>The maximal radius of an agent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frand</td><td>Function returning a random number [0..1). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">randomRef</td><td>The reference id of the random location. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">randomPt</td><td>The random location. [(x, y, z)] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<a class="anchor" id="ac42040cc55792543570e6078e524e7a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::findStraightPath </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>pathSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>straightPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>straightPathFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>straightPathRefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>straightPathCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxStraightPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the straight path from the start to the end position within the polygon corridor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startPos</td><td>Path start position. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endPos</td><td>Path end position. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>An array of polygon references that represent the path corridor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathSize</td><td>The number of polygons in the <code>path</code> array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">straightPath</td><td>Points describing the straight path. [(x, y, z) * <code>straightPathCount</code>]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">straightPathFlags</td><td>Flags describing each point. (See: <a class="el" href="DetourNavMesh_8h.html#ac8cecf1c1e32f8464a1905edfeaebbc7" title="Vertex flags returned by dtNavMeshQuery::findStraightPath. ">dtStraightPathFlags</a>) [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">straightPathRefs</td><td>The reference id of the polygon that is being entered at each point. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">straightPathCount</td><td>The number of points in the straight path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxStraightPath</td><td>The maximum number of points the straight path arrays can hold. [Limit: &gt; 0] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Query options. (see: <a class="el" href="DetourNavMesh_8h.html#a41a7f5b74dd90b219858a75208bcac4e" title="Options for dtNavMeshQuery::findStraightPath. ">dtStraightPathOptions</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>This method peforms what is often called 'string pulling'.</p>
<p>The start position is clamped to the first polygon in the path, and the end position is clamped to the last. So the start and end positions should normally be within or very near the first and last polygons respectively.</p>
<p>The returned polygon references represent the reference id of the polygon that is entered at the associated path position. The reference id associated with the end point will always be zero. This allows, for example, matching off-mesh link points to their representative polygons.</p>
<p>If the provided result buffers are too small for the entire result set, they will be filled as far as possible from the start toward the end position. </p>

</div>
</div>
<a class="anchor" id="a6bf7b20019f41314efa52f6fc9f4789a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdtNavMesh.html">dtNavMesh</a>* dtNavMeshQuery::getAttachedNavMesh </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the navigation mesh the query object is using. </p>
<dl class="section return"><dt>Returns</dt><dd>The navigation mesh the query object is using. </dd></dl>

</div>
</div>
<a class="anchor" id="ad342acec1028a02af2a45910f15e7bdb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="classdtNodePool.html">dtNodePool</a>* dtNavMeshQuery::getNodePool </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the node pool. </p>
<dl class="section return"><dt>Returns</dt><dd>The node pool. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ba30d075826336a6ad68624e4cc3c47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::getPolyHeight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the height of the polygon at the provided position using the height detail. </p>
<p>(Most accurate.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The reference id of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>A position within the xz-bounds of the polygon. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">height</td><td>The height at the surface of the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Will return <a class="el" href="DetourStatus_8h.html#ae3cf4ee7a8ebe23a82381ffe0952fe3f">DT_FAILURE</a> if the provided position is outside the xz-bounds of the polygon. </p>

</div>
</div>
<a class="anchor" id="a98ff91171b3455e8c99a5faef19a548f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::getPolyWallSegments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>segmentVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>segmentRefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>segmentCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxSegments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the segments for the specified polygon, optionally including portals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The reference id of the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">segmentVerts</td><td>The segments. [(ax, ay, az, bx, by, bz) * segmentCount] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">segmentRefs</td><td>The reference ids of each segment's neighbor polygon. Or zero if the segment is a wall. [opt] [(parentRef) * <code>segmentCount</code>] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">segmentCount</td><td>The number of segments returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSegments</td><td>The maximum number of segments the result arrays can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>If the <code>segmentRefs</code> parameter is provided, then all polygon segments will be returned. Otherwise only the wall segments are returned.</p>
<p>A segment that is normally a portal will be included in the result set as a wall if the <code>filter</code> results in the neighbor polygon becoomming impassable.</p>
<p>The <code>segmentVerts</code> and <code>segmentRefs</code> buffers should normally be sized for the maximum segments per polygon of the source navigation mesh. </p>

</div>
</div>
<a class="anchor" id="acb51d0d2798d0bc7c669ac38c25d4116"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdtNavMesh.html">dtNavMesh</a> *&#160;</td>
          <td class="paramname"><em>nav</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the query object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nav</td><td>Pointer to the <a class="el" href="classdtNavMesh.html" title="A navigation mesh based on tiles of convex polygons. ">dtNavMesh</a> object to use for all queries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxNodes</td><td>Maximum number of search nodes. [Limits: 0 &lt; value &lt;= 65536] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>Must be the first function called after construction, before other functions are used.</p>
<p>This function can be used multiple times. </p>

</div>
</div>
<a class="anchor" id="a16e37c345635df5b3a38b4ea0b9bdbb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::initSlicedFindPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>endRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intializes a sliced path query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The refrence id of the start polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endRef</td><td>The reference id of the end polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startPos</td><td>A position within the start polygon. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endPos</td><td>A position within the end polygon. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Calling any non-slice methods before calling <a class="el" href="classdtNavMeshQuery.html#a98673bb238fbb139ec8407e266fa76fd" title="Finalizes and returns the results of a sliced path query. ">finalizeSlicedFindPath()</a> or <a class="el" href="classdtNavMeshQuery.html#a01b18dcb5d25fc392b6030ae5d4f310e" title="Finalizes and returns the results of an incomplete sliced path query, returning the path to the furth...">finalizeSlicedFindPathPartial()</a> may result in corrupted data!</dd></dl>
<p>The <code>filter</code> pointer is stored and used for the duration of the sliced path query. </p>

</div>
</div>
<a class="anchor" id="a8c545e9d04c75c7e5f895cb8f4b5ab86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dtNavMeshQuery::isInClosedList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>ref</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the polygon reference is in the closed list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The reference id of the polygon to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the polygon is in closed list.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>The closed list is the list of polygons that were fully evaluated during the last navigation graph search. (A* or Dijkstra) </p>

</div>
</div>
<a class="anchor" id="af297613a9433a98f85cdadcba298bc16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dtNavMeshQuery::isValidPolyRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the polygon reference is valid and passes the filter restrictions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>The polygon reference to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The filter to apply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4652499f16b04137b920123f224909b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::moveAlongSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>resultPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>visitedCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxVisitedSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves from the start to the end position constrained to the navigation mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the start polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startPos</td><td>A position of the mover within the start polygon. [(x, y, x)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endPos</td><td>The desired end position of the mover. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultPos</td><td>The result position of the mover. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">visited</td><td>The reference ids of the polygons visited during the move. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">visitedCount</td><td>The number of polygons visited during the move. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxVisitedSize</td><td>The maximum number of polygons the <code>visited</code> array can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>This method is optimized for small delta movement and a small number of polygons. If used for too great a distance, the result set will form an incomplete path.</p>
<p><code>resultPos</code> will equal the <code>endPos</code> if the end is reached. Otherwise the closest reachable position will be returned.</p>
<p><code>resultPos</code> is not projected onto the surface of the navigation mesh. Use <a class="el" href="classdtNavMeshQuery.html#a3ba30d075826336a6ad68624e4cc3c47" title="Gets the height of the polygon at the provided position using the height detail. ">getPolyHeight</a> if this is needed.</p>
<p>This method treats the end position in the same manner as the <a class="el" href="classdtNavMeshQuery.html#a8c7ef4c9350246c5b3b935385a90a79e" title="Casts a &#39;walkability&#39; ray along the surface of the navigation mesh from the start position toward the...">raycast</a> method. (As a 2D point.) See that method's documentation for details.</p>
<p>If the <code>visited</code> array is too small to hold the entire result set, it will be filled as far as possible from the start position toward the end position. </p>

</div>
</div>
<a class="anchor" id="aee3e80791c1d29b6defa5fb17682ec1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::queryPolygons </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>polys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>polyCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxPolys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds polygons that overlap the search box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">center</td><td>The center of the search box. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extents</td><td>The search distance along each axis. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">polys</td><td>The reference ids of the polygons that overlap the query box. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">polyCount</td><td>The number of polygons in the search result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPolys</td><td>The maximum number of polygons the search result can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>If no polygons are found, the function will return <a class="el" href="DetourStatus_8h.html#ace78a9666e74d996b468942e7434989a">DT_SUCCESS</a> with a <code>polyCount</code> of zero.</p>
<p>If <code>polys</code> is too small to hold the entire result set, then the array will be filled to capacity. The method of choosing which polygons from the full set are included in the partial result set is undefined. </p>

</div>
</div>
<a class="anchor" id="a8c7ef4c9350246c5b3b935385a90a79e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::raycast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a>&#160;</td>
          <td class="paramname"><em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdtQueryFilter.html">dtQueryFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hitNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detour.html#gab4e0b2257a670c1a800057999612b466">dtPolyRef</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pathCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts a 'walkability' ray along the surface of the navigation mesh from the start position toward the end position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startRef</td><td>The reference id of the start polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startPos</td><td>A position within the start polygon representing the start of the ray. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endPos</td><td>The position to cast the ray toward. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">t</td><td>The hit parameter. (FLT_MAX if no wall hit.) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hitNormal</td><td>The normal of the nearest wall hit. [(x, y, z)] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The polygon filter to apply to the query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">path</td><td>The reference ids of the visited polygons. [opt] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pathCount</td><td>The number of visited polygons. [opt] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPath</td><td>The maximum number of polygons the <code>path</code> array can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query.</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>This method is meant to be used for quick, short distance checks.</p>
<p>If the path array is too small to hold the result, it will be filled as far as possible from the start postion toward the end position.</p>
<p><b>Using the Hit Parameter (t)</b></p>
<p>If the hit parameter is a very high value (FLT_MAX), then the ray has hit the end position. In this case the path represents a valid corridor to the end position and the value of <code>hitNormal</code> is undefined.</p>
<p>If the hit parameter is zero, then the start position is on the wall that was hit and the value of <code>hitNormal</code> is undefined.</p>
<p>If 0 &lt; t &lt; 1.0 then the following applies:</p>
<div class="fragment"><div class="line">distanceToHitBorder = distanceToEndPosition * t</div>
<div class="line">hitPoint = startPos + (endPos - startPos) * t</div>
</div><!-- fragment --><p><b>Use Case Restriction</b></p>
<p>The raycast ignores the y-value of the end position. (2D check.) This places significant limits on how it can be used. For example:</p>
<p>Consider a scene where there is a main floor with a second floor balcony that hangs over the main floor. So the first floor mesh extends below the balcony mesh. The start position is somewhere on the first floor. The end position is on the balcony.</p>
<p>The raycast will search toward the end position along the first floor mesh. If it reaches the end position's xz-coordinates it will indicate FLT_MAX (no wall hit), meaning it reached the end position. This is one example of why this method is meant for short distance checks. </p>

</div>
</div>
<a class="anchor" id="aa0c147e3da7fd0b59342da0fc456afc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="DetourStatus_8h.html#a4f23c0dcf28d9e299a4aa06af5b9ada3">dtStatus</a> dtNavMeshQuery::updateSlicedFindPath </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>doneIters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates an in-progress sliced path query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxIter</td><td>The maximum number of iterations to perform. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">doneIters</td><td>The actual number of iterations completed. [opt] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status flags for the query. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="DetourNavMeshQuery_8h_source.html">DetourNavMeshQuery.h</a></li>
<li><a class="el" href="DetourNavMeshQuery_8cpp.html">DetourNavMeshQuery.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->

    <li class="footer">
      <a href="http://masagroup.github.io/recastdetour/">Home</a> 
      | <a href="https://github.com/masagroup/recastdetour"> Sources</a>
      | <a href="./License.html"> License</a>
	</li>
   </ul>
 </div>
</body>
</html>
